> source https://halltape.github.io/HalltapeRoadmapDE/QUESTION/Python/

Вопросы по Python.

* Лямбда функция (что это, зачем, где использовать)?
лямбда функция - это анонимная функция, которая используется в случаях когда нам надо произвести вычисление один раз, поэтому нет необходимости называть эту функцию.
может иметь много входных параметров, но одно возвращаемое значение.
Функция обозначается ключевым словом lambda.

* Назовите принципы ООП?
инкапсуляция (слабо связанные модули), полиморфизм, наследование, абстракция.

* В чем разница "==" и "is"?
== проверяется совпадают ли значения у двух переменных.
is проверяется указывают ли две переменные на один и тот же объект.

* Что такое Self, для чего нужен, как и где используется?
это переменная содержит экземпляр класса, передается как параметр функций, чтобы было явно видно, откуда она берется и когда мы обращаемся к переменным и методам класса.

* В чем разница между определением функции func и func()?
func - это сама функция как объект, ее можно передавать как значение в параметры функции, 
а func() - это вызов функции (Python выполняет __call__ у объекта func), возвращает результат выполнения функции.

* Назови изменяемые и неизменяемые объекты.
Неизменяемыми являются целые и действительные числа (int, float), строки (str), последовательности байтов (бинарные данные, bytes), а также кортежи, все элементы которых неизменяемы (tuple). 
Напротив, списки (list), словари (dict) и множества (set) являются изменяемыми. 
Такое деление введено для безопасности, предсказуемости кода и оптимизации.
Изменяемые объекты как ключ от двери - один раз сделали, и всегда такой же.
неизменяемые как коробка - можно что-то в нее положить или убрать, но коробка остается такой же.

* Что такое Декоратор?
это функция, которая принимает на вход другую функцию в качестве аргумента, добавляет к ней дополнительную функциональность и возвращает измененную функцию.
Декораторы помогают дополнять поведение функций без изменения самого кода функции.

* Что такое Генератор? Какие есть варианты определения генераторов?
генератор это объект, который вычисляет элементы последовательности по требованию.
Генератор - это разновидность итератора, но его проще реализовать, так как в отличие от итератора генератор сам автоматически запоминает, где был остановлен.
Итератор - это объект с методами __iter__() и __next__(), который вручную управляет состоянием.
Генератор можно создать с помощью yield и с помощью генераторного выражения.

* Как рассчитывается сложность алгоритма? на примере list, tuple

* Как передаются аргументы в функцию?
по позиции в списке аргументов и по ключевому слову аргумента.
С версии 3.8 можно явно ограничить способ передачи аргумента, определить, что можно передавать аргументы только по ключу, только по аргументу или и по ключу и по аргументу.

* Что такое super() и зачем нужен?
это встроенная функция, которая делегирует вызов метода некоторому классу в дереве предка, нужный класс ищется с помощью mro - Method Resolution Order, порядок поиска / дерево предков.

* Что такое итерация? Что такое итератор?
итерация - это повторение блока кода в рамках циклического процесса для обработки элементов последовательности по одному за раз.
python использует цикл for для выполнения итераций над итерируемые объектами, которые представляют собой объекты способные возвращать элементы по очереди, используя итераторы.
Итерируемый объект (iterable) - это объект, который можно перебирать, он должен иметь специальный метод, который позволяет получать элементы по одному.
Итератор - это объект, который реализует процесс перебора. Он хранит состояние и предоставляет метод next для возврата следующего элемента из итерируемого объекта.
Когда элементы заканчиваются, итератор генерирует исключение StopIteration.

* Можно ли на одну функцию нацепить несколько декораторов и как они будут считываться?

Да, можно.

    @decorator1
    @decorator2
    @decorator3
    def func():
        ...

это то же самое, что и 

    func = decorator1(decorator2(decorator3(func)))

То есть декораторы будут выполняться последовательно от самому близкому к функции до самого верхнего, то есть decorator3 отработает первым.
Несколько декораторов следующих друг за другом не декорируют друг друга.
Они изменяют функцию и ее измененный вариант передают в порядке следования друг другу в качестве аргумента.
Пример - это несколько декораторов которые применяют к тексту разные стили (bold, italic)

* Функция, которая используется в качестве аргумента другой функции, может использовать свои аргументы?
поскольку функция в python явялется объектом, то ее можно передавать как аргумент другой функции, при этом передается ссылка на функцию.
Функции, которые могут принимать другие функции в качестве аргумента, называются функциями высшего порядка.

Функция, которая используется в качестве аргумента другой функции, может использовать свои аргументы, для этого ей нужно задать эти аргументы при вызове из основной функции.


* Что представляет из себя тип данных Int в Python?
Тип данных int (целые числа) в Python представляет собой неотрицательные и отрицательные целые числа без дробной части, которые могут быть неограниченно большими, в отличие от других языков программирования. Он используется для хранения количественной информации и выполнения математических операций. В Python целые числа могут быть представлены в десятичной, двоичной, восьмеричной и шестнадцатеричной системах счисления, а также могут быть преобразованы из строк или чисел с плавающей точкой с помощью функции int()

* Какая типизация используется в Python?
В Python используется строгая динамическая типизация. 
"Динамическая" означает, что типы объектов определяются во время выполнения программы (runtime), а не при её написании. 
"Строгая" означает, что язык не допускает неявных преобразований между несовместимыми типами данных, требуя явного указания действий, что помогает избежать ошибок, свойственных слабой типизации
Динамическая типизация: Вы можете присвоить переменной значение одного типа, а затем в той же переменной — значение другого типа. При этом вам не нужно заранее указывать тип переменной.

Строгая типизация: Python не позволит вам, например, прибавить число к строке без предварительного преобразования, вызовет исключение TypeError.

* Что может быть ключём словаря?
любые неизменяемые типы данных
Основные правила для ключей словаря: 

Неизменяемость:
Ключ должен быть объектом, который нельзя изменить после создания.
Уникальность:
Каждый ключ в словаре должен быть уникальным. Если вы попытаетесь добавить элемент с уже существующим ключом, предыдущее значение будет перезаписано последним.

* Класс вида:

    class MyClass:
        pass

может быть ключём словаря? Если нет, то что необходимо добавить? 

Нет, класс как таковой (объект класса) не может быть ключом словаря, потому что он является изменяемым типом данных. 
Ключами могут быть только неизменяемые типы, такие как числа, строки, кортежи и логические значения. 
Чтобы использовать экземпляр класса в качестве ключа, необходимо реализовать в классе два метода: 
__hash__() и __eq__() для обеспечения неизменяемости и уникальности объекта

* В чем различие между return и yield? 
Основное отличие заключается в том, что return завершает функцию и возвращает одно значение, в то время как yield приостанавливает выполнение функции, сохраняет её состояние и возвращает одно значение из последовательности, позволяя продолжить работу позже с того места, где она была остановлена. 
return используется в обычных функциях для возврата конечного результата, тогда как yield превращает функцию в генератор, который поэтапно выдаёт значения, экономя память, особенно при работе с большими наборами данных или бесконечными последовательностями

* Что обозначает ключевое слово is? 
это ключевое слово, которое используется для проверки двух объектов, являются ли одним и тем же объектом.
вернет false, если объекты имеют полностью одинаковое значение, но не являются одним и тем же объектом (занимают разную область в памяти, разный id()).

* Есть функция, в ней передается аргумент **qwe, что это обозначает? 
В Python две звездочки перед qwe (**qwe) означают, что функция ожидает неопределенное количество именованных аргументов, которые будут собраны в словарь. qwe в этом случае будет ключом словаря, а значение qwe — соответствующее ему значение, переданное при вызове функции

* Что такое try, except, else, finally? 
В Python конструкция try-except-else-finally используется для обработки исключений (ошибок). 
try содержит код, который может вызвать ошибку; 
except перехватывает и обрабатывает конкретные ошибки; 
else выполняется, если в блоке try ошибок не произошло; 
а finally выполняется в любом случае, независимо от того, была ошибка или нет, что полезно для освобождения ресурсов

* Что выведет print(a)?

    a = [1,2,3]
    b = a
    b.append(4)

Выведет [1, 2, 3, 4].

* Как работает сборщик мусора в python?
есть несколько основных понятий в работе сборщика мусора в python: подсчет ссылок, отслеживание циклических ссылок, встроенный модуль python gc,
поколенческий подход к сбору мусора.
Лучшие практики:
использовать менеджеры контекста, 
использовать автоматическую сборку мусора, 
мониторинг использования памяти с помощью модулей gc и tracemalloc, 
оптимизировать использование памяти (подходящие типы данных, подходящие встроенные структуры и итераторы, экономящие память например генераторы, не создавать не нужные объекты).

* Как работает память в питоне?
напрямую из кода выделение памяти не управляется. Python имеет заранее выделенный от ОС участок памяти, который он автоматически распределяет между объектами.
Python оптимизирует использование памяти с помощью механизма итернирования - это оптимизация при которой интерпретатор хранит только одну копию каждого уникального неизменяемого объекта (например, два пустых кортежа будут указывать на одно место в памяти).

* Можно ли в словарь в key записать изменяемый тип? Почему?
нет, так как ключами словарей в Python могут быть только неизменяемые типы данных (числа, строки, кортежи), 
поскольку словари используют эти ключи для быстрого определения местоположения и доступа к связанным значениям. 
Если бы ключи были изменяемыми, их значения могли бы меняться, что нарушило бы внутреннюю структуру словаря и привело бы к непредсказуемому поведению при поиске данных. 
При поиске значения по ключу, Python вычисляет хеш (уникальный идентификатор) этого ключа и использует его для определения места, где хранится соответствующее значение
Причины: Целостность данных, Предотвращение несоответствий, Эффективность поиска.