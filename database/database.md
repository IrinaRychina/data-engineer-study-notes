> source https://halltape.github.io/HalltapeRoadmapDE/QUESTION/Data_Base/

* Для чего нужен ACID? Объясни своими словами понятия: Атомарность, Согласованность, Изоляция и Устойчивость.
Атомарность (COMMIT или ROLLBACK, использует журнал транзакций (логирование) для отслеживания всех изменений и для корректного отката всех изменений) - пример с переводом денег между счетами.
Согласованность Consistency (Ограничения целостности - Первичные, внешние ключи, NOT NULL, CHECK; Триггеры и хранимые процедуры - для поддержания бизнес правил) - пример нельзя чтобы количество товара стало отрицательным.
Устойчивость (Durability (сохраняемость) - Энергонезависимая память, Репликация данных, Журналирование).
Изоляция - другие транзакции не видят промежуточного, некорректного состояния (Блокировки (Locking), Временные метки (Timestamping))



* Какие существуют уровни Изоляции в сатндарте SQL?
Стандарт SQL определяет четыре уровня изоляции: 
Read Uncommitted (возможны грязные чтения), 
Read Committed (только зафиксированные данные, возможны non-repeatable reads. Пример: проверяем баланс счёта, видим 100 -> другая транзакция списывает 50 -> повторно читаем, видим 50. Логика транзакции ломается.), 
Repeatable Read (повторные SELECT видят одни и те же данные, но возможны фантомы. Пример: рассчитываем количество заказов за день, думаем, что их 5 -> фантом добавился, а расчёт становится некорректным.),
Serializable (строгая последовательность, нет аномалий, но меньше параллелизма).

* Что такое методология BASE и чем она отличается от ACID?
BASE
Принципы для масштабируемых распределённых систем (NoSQL, OLAP):
Basically Available — система доступна почти всегда.
Soft state — состояние системы может временно быть несогласованным.
Eventual consistency — в итоге данные станут согласованными.
Цель: высокая доступность и масштабируемость, допускается временная неконсистентность.

Пример: социальная сеть — лайк пользователя может появиться с небольшой задержкой на всех репликах, но в итоге всё синхронизируется.

Цель ACID - это Строгая консистентность, цель BASE - Высокая доступность и масштабируемость.
в ACID не допускается неконсистентность, в BASE допускается временная неконсистентность.
Примеры
ACID: Банки, ERP
BASE: Соцсети, крупные распределённые сервисы, NoSQL базы

* Что такое и для чего нужен индекс в БД?
Индекс в базе данных — это специальная структура данных, которая ускоряет поиск, сортировку и фильтрацию данных в таблице, 
аналогично оглавлению в книге. Для чего нужен: чтобы значительно сократить время обработки запросов к большим таблицам, 
так как серверу не нужно сканировать всю таблицу целиком, 
а достаточно найти нужную информацию в упорядоченной структуре индекса

* Какие типы индексов существуют?
B-tree: самый распространённый, подходит для точного и диапазонного поиска.
Hash: эффективен для точного поиска, но не для диапазонов.
В PostgreSQL есть специальные: GIN для массивов и полнотекстового поиска, GiST для геоданных, BRIN для очень больших таблиц.
Индексы могут быть уникальными - гарантия уникальности значений, или неуникальными.
Также есть покрывающие индексы, которые содержат дополнительные колонки, чтобы запрос выполнялся полностью через индекс без обращения к таблице.

* Чем отличается кластеризованный индек от некластеризованного?
Кластеризованный индекс хранит данные таблицы в физическом порядке, обычно на первичном ключе, что ускоряет диапазонные запросы и сортировку. Некластеризованный индекс — это отдельная структура с ссылками на строки, их может быть много, они ускоряют поиск по разным колонкам, но для чтения данных нужен дополнительный доступ к таблице

* Сколько у таблицы может быть кластеризованных индексов?
Один, так как кластеризованный индекс определяет физический порядок хранения строк таблицы, поэтому логически невозможно хранить данные в нескольких порядках одновременно.
Обычно он создаётся на первичном ключе, но можно выбрать и другую колонку.

* Можно ли строить индекс по JSON полям?
Да, можно. В PostgreSQL создают GIN-индексы по JSONB для поиска по ключам и значениям, а в MySQL используют виртуальные колонки с индексом. В Elasticsearch весь JSON-документ индексируется для быстрого поиска

* Чем отличается материализованное представление от нематериализованного?
Нематериализованное представление — это просто SQL-запрос (VIEW), который выполняется при каждом обращении, поэтому всегда актуален, но может быть медленным. Материализованное представление хранит результат запроса физически, что ускоряет доступ, но требует обновления при изменении базовых данных
Например, на сайте с большим количеством заказов можно создать материализованное представление с суммой продаж по каждому товару, чтобы быстро строить отчёты, не пересчитывая их каждый раз

* Можно ли читать данные из материализованного представления, когда выполняется команда REFRESH?
В PostgreSQL обычный REFRESH блокирует чтение, но с опцией CONCURRENTLY данные остаются доступными для чтения во время обновления. В других СУБД поведение зависит от настроек обновления

* Как устроена система транзакций в PostgreSQL?
В PostgreSQL система транзакций устроена вокруг принципа ACID: атомарность, согласованность, изолированность и долговечность.
Транзакция начинается с команды BEGIN и заканчивается COMMIT или ROLLBACK.
PostgreSQL использует MVCC (Multiversion Concurrency Control), что позволяет одновременно читать и писать данные без блокировок на чтение. Каждая транзакция видит снимок данных на момент начала транзакции.
Для изоляции есть уровни: READ COMMITTED (по умолчанию), REPEATABLE READ, SERIALIZABLE.
В случае ошибки можно выполнить ROLLBACK, и все изменения транзакции отменяются, что обеспечивает атомарность
* Что из себя представляет СТЕ?
СТЕ (Common Table Expression) — это временный результат запроса, который создаётся через WITH и используется в основном запросе. Он улучшает читаемость сложных запросов и поддерживает рекурсию

* Какие виды баз данных ты знаешь?
Реляционные (SQL) хранят данные в таблицах и поддерживают ACID — например, PostgreSQL, MySQL. Документо-ориентированные (NoSQL) работают с JSON-документами, например MongoDB. Колонко-ориентированные, как ClickHouse, хороши для аналитики. 
Есть ещё ключ-значение, например Redis. Redis хранит данные в памяти, поэтому очень быстрый. Простая модель ключ-значение и поддержка TTL идеально подходят для кеша и сессий. Кроме того, Redis обеспечивает атомарные операции, что удобно для счетчиков и очередей задач
и графовые, например Neo4j, для хранения связей между объектами
Колонко-ориентированные базы — для аналитики больших данных, ключ-значение — для быстрого доступа по ключу, графовые — для анализа связей.

* Чем отличаются колоночные БД от строковых?
Строковые базы хранят данные построчно и хорошо подходят для транзакций, колоночные — по колонкам, что ускоряет аналитические запросы и агрегирование по большим таблицам.
Плюсы колоночных бд:
Отлично для аналитики, когда нужны только некоторые колонки, так как меньше I/O.
Эффективное сжатие колонок (однородные типы), экономия памяти.
Минусы:
Чтение всей строки медленнее, чем в строковых БД, потому что нужно собрать данные из разных колонок.
Подходит меньше для OLTP, где часто обновляют отдельные строки.

* Для чего нужны схемы и табличные пространства?
Схемы — это логическое объединение таблиц, индексов и других объектов внутри базы, позволяющее структурировать данные по функционалу или модулю, а также управлять правами доступа. Табличные пространства — это физические места на диске, где хранятся объекты базы, что позволяет распределять данные по разным устройствам для повышения производительности и удобного управления хранением

* Для чего нужна репликация данных, какие виды существуют и примеры сценариев репликаций?
Репликация нужна для отказоустойчивости, балансировки нагрузки и географического распределения. Она бывает синхронная, асинхронная, логическая и физическая.
Зачем нужна репликация данных:
Повышение доступности и отказоустойчивости,
Балансировка нагрузки на чтение,
Балансировка нагрузки на чтение,
Географическое распределение.

Виды репликации:
Синхронная репликация: Главный сервер ждёт подтверждения от реплики перед завершением транзакции, высокая консистентность данных, но медленнее.
Асинхронная репликация: Главный сервер не ждёт реплики, данные обновляются с задержкой, возможна короткая несогласованность данных.
Логическая репликация (PostgreSQL): Реплицируются отдельные таблицы или наборы данных.
Физическая репликация: Реплицируется вся база целиком, на уровне файлов WAL.

* Объясни CDC подход?
CDC — это подход, когда фиксируются только изменения данных (INSERT, UPDATE, DELETE) и передаются в другие системы. Он позволяет синхронизировать данные в реальном времени, экономя ресурсы по сравнению с полными загрузками
Кроме CDC, есть классический ETL/ELT — пакетная обработка данных, и событийно-ориентированный подход через потоки событий (Kafka, RabbitMQ). CDC выделяется тем, что отслеживает изменения в реальном времени без полной перезагрузки таблиц
CDC отслеживает изменения прямо в базе данных и передаёт их другим системам, тогда как event-driven подход публикует события приложения — не только данные, но и бизнес-события. CDC подходит для синхронизации и аналитики, а event-driven — для реактивной архитектуры и микросервисов

* Что такое партицирование таблиц, их виды и примеры применения использования?
Партицирование таблиц — это разделение большой таблицы на логические части для удобства управления и ускорения запросов. 
Существует диапазонное (Данные делятся по диапазонам значений колонки, например по месяцам), 
списковое (Данные делятся по списку значений, например, по региону), 
хэшевое (Данные распределяются по хэшу значения колонки для равномерного распределения, например по user_id % 4) 
и комбинированное партицирование. 
Например, заказы можно разделить по месяцам для аналитики или по регионам для ускорения выборки
Примеры использования: 
Аналитика: большие таблицы с миллионами строк → ускорение агрегатных запросов по диапазонам дат.
Архивирование: старые данные можно переместить в отдельные партиции и легко удалять.
Балансировка нагрузки: разные партиции могут храниться на разных дисках или серверах.
OLTP: ускорение поиска по ключевым колонкам, если есть партицирование.

* В каких случаях лучше использовать БД со строковым хранением, а в каких с колоночным?
Строковые базы подходят для транзакционных систем с частым доступом к целым строкам, колоночные — для аналитики больших данных, когда нужно быстро агрегировать или фильтровать отдельные колонки

* Влияет ли колоночное хранение на скорость доступа к данным в случаях чтения, удаления и изменения?
Колоночное хранение ускоряет чтение отдельных колонок, особенно при аналитике, но замедляет операции удаления и обновления отдельных строк. 
Поэтому колоночные базы чаще используют для аналитики и OLAP, а строковые — для транзакционных OLTP-систем.

* За счет чего в стоковых БД мы можем быстрее обращаться к полному набору данных, в отличии от колоночных?
В строковых базах весь набор данных строки хранится подряд, поэтому чтение всех колонок одной строки быстрее, СУБД считывает их одним блоком I/O. 
В колоночных базах нужно собрать строку из разных колонок, что увеличивает время доступа

* Что такое B-tree индекс? Как он работает? Какая сложность данного алгоритма?
B-tree индекс — это сбалансированное дерево, которое ускоряет поиск, вставку и удаление данных. 
Он хранит ключи в узлах, позволяет быстро переходить по дереву к нужной строке. 
Сложность всех операций (поиск, вставка, удаление) — O(logn). Особенно эффективен для диапазонных запросов и сортировки.
Высокая эффективность достигается за счёт сбалансированности дерева, минимизации числа дисковых чтений.
поиск: идём сверху вниз по дереву, сравнивая ключ с ключами в узле → быстро находим нужную страницу.
Вставка/удаление: дерево автоматически балансируется, чтобы высота оставалась минимальной.

* Для чего используется шардирование и репликация?
Репликация
Зачем:
Обеспечивает отказоустойчивость (если один сервер падает, другой хранит копию).
Делает чтение быстрее (реплики можно использовать для read-запросов).
Используется для геораспределённых систем (реплики ближе к пользователям в разных регионах).

Пример: в интернет-магазине PostgreSQL мастер принимает INSERT/UPDATE (запись), а несколько реплик отдают SELECT-запросы (чтение).

Минусы / ограничения:
Задержка синхронизации
Асинхронная репликация может привести к кратковременной несогласованности данных.
Сложноть при записи
Все изменения идут через основной сервер (мастер), что может быть узким местом при высокой нагрузке на запись.
Управление репликами
Нужно следить за синхронизацией, восстанавливать реплики при сбоях, что добавляет сложность.

Шардирование
Зачем:
Делит очень большие таблицы между несколькими серверами.
Уменьшает нагрузку на один узел.
Позволяет масштабировать БД по горизонтали (добавлять новые серверы при росте данных).

Пример: в соцсети пользовательские данные можно шардировать по user_id % N → каждый шард хранит часть пользователей.

Минусы / ограничения:
Сложность запросов
JOIN и агрегаты между разными шардами могут быть медленными или требовать сложной логики на уровне приложения.
Балансировка нагрузки
Неправильное распределение данных может привести к «горячим» шардам, где один сервер перегружен, а другие простаивают.
Миграция данных
При добавлении нового шарда нужно перераспределять часть данных, что сложно без остановки сервиса.

* Шардирование ускоряет работу запросов?
Шардирование ускоряет запросы, которые касаются данных одного шарда, так как работают только с частью таблицы. Для запросов, затрагивающих все шарды, оно не даёт ускорения и может даже усложнить выполнение
