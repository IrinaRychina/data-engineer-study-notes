> source https://halltape.github.io/HalltapeRoadmapDE/QUESTION/SQL/

* В каком порядке выполняется запрос и кратко охарактеризуй каждый оператор:

        SELECT t1.col_2 , 
        COUNT(*) , 
        COUNT(*) OVER() 
        FROM Table_1 AS t1
        INNER JOIN Table_2 AS t2 ON t1.id =t2.id WHERE 1 = 1 AND t1.col_1 > 2 
        GROUP BY t1.col_1 
        HAVING COUNT(*) > 1 QUALIFY COUNT(*) OVER() > 1 
        ORDER BY 2 
        LIMIT 1 
Порядок выполнения команд sql:
1. FROM/JOIN - определяется таблица, из которой будут получены данные
2. WHERE - фильтрация в соответствии с условием
3. GROUP BY - выбранные данные агрегируются
4. HAVING - из агрегированных записей выбираются записи, которые удовлетворяют условию
5. SELECT + OVER - выборка из полученных данных
6. ORDER BY - сортировка
7. LIMIT - количество строк для вывода

* Как избежать полного сканирования таблицы в SQL-запросе?
добавить фильтрацию, чтобы сначала отбросить ненужные строки, а затем выполнять действия над данными

* Какие виды команд ты знаешь? Назови примеры команд каждого вида и их задачу. 
ddl - define (CREATE, DROP, TRUNCATE. ALTER), 
dml - manipulate (INSERT, UPDATE, DELETE), 
dcl (data control language) - access rights (GRANT, REVOKE), 
dql - query (SELECT), 
tcl - transactions (ROLLBACK, COMMIT).

* Отличие DROP, DELETE, TRUNCATE. 
DROP - удаляет таблицу полностью вместе с данными, структурой, индексами необратимо
DELETE - удаляет выбранные данные, можно использовать where, срабатывают триггеры on delete, операция построчно записывается в журнал транзакций.
TRUNCATE - удалеят все данные из таблицу, сохраняя структуру таблицы, быстрее DELETE.

* Назови основные типы данных в SQL. За основу возьми любую БД.
в postgresql:
символьные, численные, логический, дата и время, бинарные.

* Назови "нестандартные" типы данных, которые ты знаешь. 
геометрические, для представления интернет адресов, для валюты.

* Различие строковых типов данных CHAR, VARCHAR, TEXT. 
char - строка с ограничением по длине n, при чем ни больше, ни меньше, по умолчанию n=1.
varchar - строка с ограничением по длине n, не больше n, по умолчанию n не установлено - строка без ограничения по размеру
text - строка без ограничения для хранения строк большого размера.

* Назовите логические виды JOIN и для чего они нужны. 
inner - возвращает записи только если есть соответствие в обеих таблицах, 
outer - возвращает все записи из левой и правой, когда есть соответствие, 
cross - декартово призведение всех записей, 
left - возвращает все записи из левой таблицы и соотвествующие записи из правой, 
right - возвращает все записи из правой таблицы и соотвествующие записи из левой.

* В чем отличие cross и full outer join?
cross join - это join, результатом которого будет декартово произведение всех записей. Пример использования - нужно показать покупателю список всех машин во всех возможных цветах.
full outer join - выводит результаты по условию совпадения ON, если даже если подходящая под условие запись есть только в одной из соединяемых таблиц и нет в другой.
Пример использования - вывести товары объединенные со всеми категориями, даже если в некоторых категориях нет товаров и некоторые товары не принадлежат ни одной категории.

* Назовите физические виды JOIN и их принцип работы. 
* Как определить, что функция является оконной?
это функция которая работает с выделенным набором строк.

* Назови виды оконных функций.
агрегирующие, ранжирующие, функции смещения

* В чем разница между RANK и DENSE_RANK?
возвращают ранг каждой строки, RANK учитывает повторяющиеся значения при присваивании ранга (может оставлять пропуски в нумерации), а DENSE_RANK - нет.

* Как определяется окно строк в оконной функции? Объясни, как понимаешь принцип работы оконной функции. 
окно строк определяется пользователем и передается в функцию, по колонкам partition by либо по количеству строк ROWS/RANGE.
Оконные функции позволяют вычислять результат над набором строк, не сворачивая их в одну как в агрегации.

* Как применял оконные функции на практике? Расскажи пример из жизни. (Если такого примера нет, посмотри "Алгоритм поиска" (Сделай пост на данную тему и не забудь вставить ссылку на него)).

* Как ты понимаешь, для чего нужно оптимизировать запросы?
для того чтобы программа не поглощала все ресурсы, чтобы могла выдерживать нагрузки из множества пользователей

* В чем различия команд EXPLAIN и EXPLAIN ANALYZE? 
EXPLAIN - это предполагаемый план выполнения на основе статистики таблиц, можно выполнять операции insert/delete/update без настоящего обновления и выполнять сложные выборки select не нагружая таблицу.
EXPLAIN ANALYZE - это реальное выполнение запроса и предоставление плана запроса.

* Расскажи алгоритм того, как бы ты оптимизировал запрос.
я бы использовала команду explain для того, чтобы увидеть план запроса.
затем искала бы в плане узкие места.
Например, нужно убедиться что не происходит полное сканирование таблицы, применен фильтр если это возможно.
Изучила можно ли добавить индекс, измерила время без индекса и с индексом.
В некоторых субд можно помочь субд оптимизировать запрос, задав параметры, например использовать только index scan или наоборот не использовать.

* Что делают команды VACUUM, ANALYZE и VACUUM ANALYZE? 
VACUUM - в postgresql выполняет очистку устаревших неиспользуемых строк
ANALYZE - обновляет статистику по таблицам для оптимизатора запросов.
VACUUM ANALYZE - делает и то, и другое.

* Что такое spill таблиц? 
это данные, которые выгружаются из оперативной памяти на жесткий диск, когда не хватает оперативной памяти для выполнения запроса.

* Что выведет следующая команда:

      SELECT NULL + 5,  // NULL
             5 - NULL,  // NULL
             10 * NULL, // NULL
             10 / NULL, // NULL
             NULL / 10, // NULL
             NULL || 'какая-то прикольная фраза' // NULL
везде выведет NULL

* В чем различие команд COUNT(*) и COUNT(<имя колонки>)? 
* Как посчитать среднее значение? (Вопрос с подвохом) 
* Какими конструкциями дополняется ORDER BY, чтобы значения NULL стояли в начале и в конце таблицы? 
NULLS LAST и NULLS FIRST

* Как избавиться от NULL-значений? Как ввести ограничение на вставку NULL-значений в таблице? 
* Как разделить значение на 0, чтобы получить в ответе NULL? 
* Чем отличаются COUNT(*), COUNT(1), COUNT('a')? 
* В чем отличие между группировкой и оконной функцией? 
группировка сворачивает набор строк к одной строке, а оконная функция вычисляет результат для каждой строки.

* Чем отличаются результаты запросов:

      SELECT col1, COUNT(*) 
      FROM t1 
      GROUP BY col1;

      SELECT DISTINCT col1, COUNT(*) OVER(PARTITION BY col2)
      FROM t1

* Есть 2 таблицы: в первой 10 строк, во второй 100 строк. Назови максимальное и минимальное количество возвращаемых строк при разных видах JOIN. (Данные могут быть любые.) 
* Есть 2 таблицы: в первой 10 строк, во второй 100 строк. Назови максимальное и минимальное количество возвращаемых строк при разных видах JOIN. (Без NULL-значений и индексы не повторяются в рамках одной таблицы, т.е. в двух таблицах данные могут как повторяться, так и нет.) 
* В таблице 100 млн строк, необходимо удалить 90 млн. Как ты это сделаешь и почему? 
* Является ли следующая команда транзакцией?

      SELECT * FROM t1 WHERE id > 5;
нет, так как этот запрос не изменяет данные, это только операция чтения данных.

* Есть запрос, который работает ночью и строит отчет. Ежедневно он работал нормально и создавал отчет за 2 часа. Сегодня утром ты пришел на работу, а отчета нет. Смотришь свой пайплайн, а он все еще крутится на чтении запроса. Что могло произойти? 
* Как быстро посчитать количество строк в таблице, имеющей нормальную структуру, например, в 3 НФ, где много колонок и пусть в ней даже JSON'овский сырец хранится? Структура таблицы пусть будет следующая:

      CREATE TABLE t1 
      (
          id int primary key,
          col1 text,
          FK_id int NOT NULL,
          col2 text,
          col3 text,
          ....
          col100 jsonb
      )
* Что такое и для чего нужен подзапрос? Что такое коррелируемый и не коррелируемый подзапрос? В чем отличиие СТЕ от подзапроса? 
Подзапрос - это запрос, который включен в другой sql запрос.
Некоррелируемый запрос - это неазвисимый запрос, может выполняться независимо от основного запроса.
коррелируемый - это запрос который зависит от одного или нескольких столбоцв основного запроса, выполняется не один раз, а для каждой строки основного запроса.
cte объявляются с помощью ключевого слова with перед основным запросом, имеют лучшую читаемость, могут быть переиспользованы в рамках одного запроса, иногда имеют более высокую производительность.


* Для чего нужна временная таблица, если есть CTE? 
* Для чего нужна команда UNION и в чем её различие с UNION ALL? Какая команда работает быстрее и почему? Какие еще операции над множествами ты знаешь и что они делают? 
* Расскажи про условия в SQL. Для чего нужна конструкция CASE, как она записывается и в каких конструкциях запроса её можно использовать?
условия можно использовать, когда в разных случаях нужно получить разный результат, например в SELECT, получить одно значение если > 0, и другое если < 0.
Синтаксис:
CASE
  WHEN ... THEN ...
END
Можно использовать в SELECT, ORDER BY, WHERE, HAVING.
Еще есть условная функция IF, отличие в том что в ней можно задать только одно условие.

* Различие между конструкциями WHERE, HAVING, QUALIFY? 
WHERE - фильтрация перед оконной функцией,
QUALIFY - после оконной функции,
HAVING - фильтрует аггрегированные данные.

* С помощью каких команд выдается права доступа? 
GRANT - выдача прав пользователям, REVOKE - отмена выдачи прав для пользователя.

* Чем отличаются типы данных JSON и JSONb? 
это типы данных которые хранят данные в формате json, только JSONb преобразует данные в бинарный формат, что увеличивает время на вставку но в последствии поддерживает индексы, оптимизирует хранение и обработку.

* Что будет делать, если в плане запроса увидели Nested Loop? 
Если таблицы не большие и есть индекс, то можно ничего не делать, так как этот тип индекса нормально на них отработает.
Если таблицы большие, то нужно попробовать обновить статистику, может быть планировщик выбирает Nested Loop, так как считает что таблицы маленькие.


* Как эффективно удалить дубликаты строк в большой таблице? 

* Для чего нужна контрукция constraints?
это ограничения, которые устанавливаются для столбцов, чтобы определить допустимые значения.
